#!/usr/bin/env bash
set -euo pipefail

# git worktree helper (bare repo pattern)
# Layout: <project>/.bare/ + <project>/<branch>/

cmd="${1:-help}"
shift 2>/dev/null || true

_gwt_root() {
	local dir
	dir=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null) || {
		echo "Not in a git worktree repo" >&2
		return 1
	}
	echo "${dir%/.bare}"
}

# Check if cwd is a bare repo root (has .git file pointing to .bare/)
_is_bare_root() {
	[[ -f .git ]] && grep -q "gitdir: ./.bare" .git 2>/dev/null
}

case "$cmd" in
clone)
	url="$1"
	dir="${2:-$(basename "$1" .git)}"
	if [[ -z "$url" ]]; then
		echo "Usage: gwt clone <url> [dir]" && exit 1
	fi
	git clone --bare "$url" "$dir/.bare"
	echo "gitdir: ./.bare" > "$dir/.git"
	cd "$dir"
	git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
	git fetch origin
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')
	default_branch="${default_branch:-main}"
	git worktree add "$default_branch" "$default_branch"
	echo "==> Ready: cd $dir/$default_branch"
	;;
add)
	branch="$1"
	base="${2:-HEAD}"
	if [[ -z "$branch" ]]; then
		echo "Usage: gwt add <branch> [base]" && exit 1
	fi
	root=$(_gwt_root)
	if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
		git worktree add "$root/$branch" "$branch"
	else
		git worktree add -b "$branch" "$root/$branch" "$base"
	fi
	echo "==> cd $root/$branch"
	;;
rm)
	branch="$1"
	if [[ -z "$branch" ]]; then
		echo "Usage: gwt rm <branch>" && exit 1
	fi
	root=$(_gwt_root)
	git worktree remove "$root/$branch"
	;;
ls)
	git worktree list
	;;
status|st)
	target="${1:-main}"
	git_common_dir=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null)
	has_gh=false
	command -v gh &>/dev/null && has_gh=true

	# Last fetch time
	fetch_head="$git_common_dir/FETCH_HEAD"
	if [[ -f "$fetch_head" ]]; then
		if [[ "$(uname -s)" == Darwin ]]; then
			fetch_epoch=$(stat -f %m "$fetch_head")
		else
			fetch_epoch=$(stat -c %Y "$fetch_head")
		fi
		now=$(date +%s)
		ago=$(( now - fetch_epoch ))
		if (( ago < 60 )); then
			fetch_ago="${ago}s ago"
		elif (( ago < 3600 )); then
			fetch_ago="$(( ago / 60 ))m ago"
		elif (( ago < 86400 )); then
			fetch_ago="$(( ago / 3600 ))h ago"
		else
			fetch_ago="$(( ago / 86400 ))d ago"
		fi
		echo "Last fetch: $(date -r "$fetch_epoch" '+%Y-%m-%d %H:%M:%S') ($fetch_ago)"
	else
		echo "Last fetch: never"
	fi
	echo ""

	# Worktree branches vs origin
	echo "Worktrees (target: $target):"
	while IFS= read -r line; do
		wt_path=$(echo "$line" | awk '{print $1}')
		wt_commit=$(echo "$line" | awk '{print $2}')
		wt_branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

		[[ "$wt_path" == */.bare ]] && continue
		[[ -z "$wt_branch" ]] && continue

		# Check against origin
		local_commit=$(git rev-parse --short "refs/heads/$wt_branch" 2>/dev/null || echo "?")

		if ! git show-ref --verify --quiet "refs/remotes/origin/$wt_branch" 2>/dev/null; then
			sync="local only"
		elif [[ "$local_commit" == "$(git rev-parse --short "refs/remotes/origin/$wt_branch" 2>/dev/null)" ]]; then
			sync="synced"
		else
			ahead=$(git rev-list --count "refs/remotes/origin/$wt_branch..refs/heads/$wt_branch" 2>/dev/null || echo 0)
			behind=$(git rev-list --count "refs/heads/$wt_branch..refs/remotes/origin/$wt_branch" 2>/dev/null || echo 0)
			parts=()
			(( ahead > 0 )) && parts+=("${ahead} ahead")
			(( behind > 0 )) && parts+=("${behind} behind")
			sync=$(printf '%s, ' "${parts[@]}"); sync="${sync%, }"
		fi

		# Check working tree for dirty state
		dirty=""
		wt_status=$(git -C "$wt_path" status --porcelain 2>/dev/null || true)
		if [[ -n "$wt_status" ]]; then
			has_staged=false
			has_unstaged=false
			has_untracked=false
			while IFS= read -r st_line; do
				index="${st_line:0:1}"
				worktree="${st_line:1:1}"
				if [[ "$index" == "?" ]]; then
					has_untracked=true
				else
					[[ "$index" != " " && "$index" != "?" ]] && has_staged=true
					[[ "$worktree" != " " && "$worktree" != "?" ]] && has_unstaged=true
				fi
			done <<< "$wt_status"
			dirty_parts=()
			[[ "$has_staged" == true ]] && dirty_parts+=("staged")
			[[ "$has_unstaged" == true ]] && dirty_parts+=("unstaged")
			[[ "$has_untracked" == true ]] && dirty_parts+=("untracked")
			dirty=$(printf '%s, ' "${dirty_parts[@]}"); dirty="${dirty%, }"
		fi

		# Merge status
		merge_info=""
		if [[ "$wt_branch" == "$target" ]]; then
			merge_info=""
		elif git merge-base --is-ancestor "refs/heads/$wt_branch" "refs/remotes/origin/$target" 2>/dev/null; then
			# Regular merge — branch commits are ancestors of target
			pr_info=""
			if [[ "$has_gh" == true ]]; then
				pr_info=$(gh pr list --head "$wt_branch" --state merged --json number,title --limit 1 --jq 'if length > 0 then "#\(.[0].number) \(.[0].title)" else empty end' 2>/dev/null || true)
			fi
			if [[ -n "$pr_info" ]]; then
				merge_info="merged via $pr_info"
			else
				merge_info="merged"
			fi
		else
			# Not a git ancestor — check gh for squash/rebase merges and open PRs
			if [[ "$has_gh" == true ]]; then
				merged_pr=$(gh pr list --head "$wt_branch" --state merged --json number,title --limit 1 --jq 'if length > 0 then "#\(.[0].number) \(.[0].title)" else empty end' 2>/dev/null || true)
				if [[ -n "$merged_pr" ]]; then
					merge_info="merged via $merged_pr"
				else
					open_pr=$(gh pr list --head "$wt_branch" --state open --json number,title --limit 1 --jq 'if length > 0 then "#\(.[0].number) \(.[0].title)" else empty end' 2>/dev/null || true)
					if [[ -n "$open_pr" ]]; then
						merge_info="open PR $open_pr"
					else
						merge_info="not merged"
					fi
				fi
			else
				merge_info="not merged"
			fi
		fi

		# Build status line
		status_parts="($sync)"
		[[ -n "$dirty" ]] && status_parts="$status_parts [$dirty]"
		if [[ -n "$merge_info" ]]; then
			printf "  %-25s %-8s %-15s %s\n" "$wt_branch" "${wt_commit:0:7}" "$status_parts" "$merge_info"
		else
			printf "  %-25s %-8s %s\n" "$wt_branch" "${wt_commit:0:7}" "$status_parts"
		fi
	done < <(git worktree list)
	echo ""

	# Remote branches not checked out as worktrees
	worktree_branches=$(git worktree list | sed -n 's/.*\[\(.*\)\].*/\1/p')
	has_remote_only=false
	while IFS= read -r ref; do
		branch="${ref#refs/remotes/origin/}"
		[[ "$branch" == "HEAD" ]] && continue
		if ! echo "$worktree_branches" | grep -qx "$branch"; then
			if [[ "$has_remote_only" == false ]]; then
				echo "Remote branches without worktree:"
				has_remote_only=true
			fi
			remote_commit=$(git rev-parse --short "$ref" 2>/dev/null)
			printf "  %-30s %s\n" "$branch" "$remote_commit"
		fi
	done < <(git for-each-ref --format='%(refname)' refs/remotes/origin/)

	if [[ "$has_remote_only" == false ]]; then
		echo "All remote branches have worktrees."
	fi
	;;
clean)
	target="${1:-main}"
	root=$(_gwt_root)

	git fetch origin "$target" 2>/dev/null

	cleaned=0
	while IFS= read -r line; do
		wt_path=$(echo "$line" | awk '{print $1}')
		wt_branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

		[[ "$wt_path" == */.bare ]] && continue
		[[ -z "$wt_branch" ]] && continue
		[[ "$wt_branch" == "$target" ]] && continue

		# Check if branch is merged (regular merge or squash/rebase via gh)
		is_merged=false
		if git merge-base --is-ancestor "refs/heads/$wt_branch" "refs/remotes/origin/$target" 2>/dev/null; then
			is_merged=true
		elif command -v gh &>/dev/null; then
			merged_pr=$(gh pr list --head "$wt_branch" --state merged --json number --limit 1 --jq 'if length > 0 then "yes" else empty end' 2>/dev/null || true)
			[[ -n "$merged_pr" ]] && is_merged=true
		fi
		if [[ "$is_merged" == true ]]; then
			echo "==> Removing merged worktree: $wt_branch"
			git worktree remove "$root/$wt_branch"
			git branch -D "$wt_branch"
			# Delete remote branch if it exists
			if git show-ref --verify --quiet "refs/remotes/origin/$wt_branch" 2>/dev/null; then
				echo "    Deleting remote branch: origin/$wt_branch"
				git push origin --delete "$wt_branch" 2>/dev/null || echo "    Failed to delete remote branch (may already be deleted)"
			fi
			cleaned=$((cleaned + 1))
		fi
	done < <(git worktree list)

	if (( cleaned == 0 )); then
		echo "No merged worktrees to clean (target: $target)"
	else
		echo "==> Cleaned $cleaned merged worktree(s)"
	fi
	;;
rename|mv)
	old_branch="$1"
	new_branch="$2"
	if [[ -z "$old_branch" || -z "$new_branch" ]]; then
		echo "Usage: gwt rename <old-branch> <new-branch>" && exit 1
	fi
	root=$(_gwt_root)
	old_path="$root/$old_branch"
	new_path="$root/$new_branch"

	if [[ ! -d "$old_path" ]]; then
		echo "Worktree not found: $old_path" >&2 && exit 1
	fi

	# Rename the branch
	git branch -m "$old_branch" "$new_branch"
	# Move the worktree directory
	git worktree move "$old_path" "$new_path"
	echo "==> Renamed: $old_branch -> $new_branch"
	echo "==> cd $new_path"
	;;
rebase)
	target="${1:-main}"
	root=$(_gwt_root)
	branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

	if [[ "$branch" == "$target" ]]; then
		echo "Already on $target, nothing to rebase" && exit 0
	fi

	git fetch origin "$target" 2>/dev/null

	# Stash dirty state if needed
	stashed=false
	if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
		echo "==> Stashing changes..."
		git stash push -u -m "gwt-rebase: auto-stash before rebase on $target"
		stashed=true
	fi

	echo "==> Rebasing $branch onto origin/$target..."
	if git rebase "origin/$target"; then
		echo "==> Rebase successful"
	else
		echo "==> Rebase failed — resolve conflicts, then run: git rebase --continue" >&2
		if [[ "$stashed" == true ]]; then
			echo "    Stashed changes will be restored after rebase completes: git stash pop" >&2
		fi
		exit 1
	fi

	# Restore stashed changes
	if [[ "$stashed" == true ]]; then
		echo "==> Restoring stashed changes..."
		git stash pop
	fi
	;;
lazygit|lg)
	if _is_bare_root; then
		# At project root — find the first worktree that isn't the bare repo
		worktree_path=$(git worktree list --porcelain | awk '/^worktree / && !/\.bare$/ {print $2; exit}')
		if [[ -z "$worktree_path" ]]; then
			echo "No worktrees found. Create one first: gwt add <branch>" >&2
			exit 1
		fi
		echo "==> Entering worktree: $worktree_path"
		cd "$worktree_path"
	fi
	exec lazygit "$@"
	;;
*)
	echo "Usage: gwt <command>"
	echo ""
	echo "Commands:"
	echo "  clone <url> [dir]      Clone as bare repo with worktree layout"
	echo "  add <branch> [base]    Add worktree (creates branch if new)"
	echo "  rm <branch>            Remove a worktree"
	echo "  ls                     List all worktrees"
	echo "  status|st [target]     Show sync/merge status of worktrees (default: main)"
	echo "  clean [target]         Remove worktrees merged into target (default: main)"
	echo "  rename|mv <old> <new>  Rename worktree branch and directory"
	echo "  rebase [target]        Rebase current branch onto target (default: main)"
	echo "  lazygit|lg             Launch lazygit (auto-enters worktree if at bare root)"
	;;
esac
