#!/usr/bin/env bash
set -euo pipefail

# git worktree helper (bare repo pattern)
# Layout: <project>/.bare/ + <project>/<branch>/

cmd="${1:-help}"
shift 2>/dev/null || true

_gwt_root() {
	local dir
	dir=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null) || {
		echo "Not in a git worktree repo" >&2
		return 1
	}
	echo "${dir%/.bare}"
}

# Check if cwd is a bare repo root (has .git file pointing to .bare/)
_is_bare_root() {
	[[ -f .git ]] && grep -q "gitdir: ./.bare" .git 2>/dev/null
}

case "$cmd" in
clone)
	url="$1"
	dir="${2:-$(basename "$1" .git)}"
	if [[ -z "$url" ]]; then
		echo "Usage: gwt clone <url> [dir]" && exit 1
	fi
	git clone --bare "$url" "$dir/.bare"
	echo "gitdir: ./.bare" > "$dir/.git"
	cd "$dir"
	git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
	git fetch origin
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')
	default_branch="${default_branch:-main}"
	git worktree add "$default_branch" "$default_branch"
	echo "==> Ready: cd $dir/$default_branch"
	;;
add)
	branch="$1"
	base="${2:-HEAD}"
	if [[ -z "$branch" ]]; then
		echo "Usage: gwt add <branch> [base]" && exit 1
	fi
	root=$(_gwt_root)
	if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
		git worktree add "$root/$branch" "$branch"
	else
		git worktree add -b "$branch" "$root/$branch" "$base"
	fi
	echo "==> cd $root/$branch"
	;;
rm)
	branch="$1"
	if [[ -z "$branch" ]]; then
		echo "Usage: gwt rm <branch>" && exit 1
	fi
	root=$(_gwt_root)
	git worktree remove "$root/$branch"
	;;
ls)
	git worktree list
	;;
status|st)
	git_common_dir=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null)

	# Last fetch time
	fetch_head="$git_common_dir/FETCH_HEAD"
	if [[ -f "$fetch_head" ]]; then
		if [[ "$(uname -s)" == Darwin ]]; then
			fetch_epoch=$(stat -f %m "$fetch_head")
		else
			fetch_epoch=$(stat -c %Y "$fetch_head")
		fi
		now=$(date +%s)
		ago=$(( now - fetch_epoch ))
		if (( ago < 60 )); then
			fetch_ago="${ago}s ago"
		elif (( ago < 3600 )); then
			fetch_ago="$(( ago / 60 ))m ago"
		elif (( ago < 86400 )); then
			fetch_ago="$(( ago / 3600 ))h ago"
		else
			fetch_ago="$(( ago / 86400 ))d ago"
		fi
		echo "Last fetch: $(date -r "$fetch_epoch" '+%Y-%m-%d %H:%M:%S') ($fetch_ago)"
	else
		echo "Last fetch: never"
	fi
	echo ""

	# Worktree branches vs origin
	echo "Worktrees:"
	while IFS= read -r line; do
		wt_path=$(echo "$line" | awk '{print $1}')
		wt_commit=$(echo "$line" | awk '{print $2}')
		wt_branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

		[[ "$wt_path" == */.bare ]] && continue
		[[ -z "$wt_branch" ]] && continue

		# Check against origin
		local_commit=$(git rev-parse --short "refs/heads/$wt_branch" 2>/dev/null || echo "?")

		if ! git show-ref --verify --quiet "refs/remotes/origin/$wt_branch" 2>/dev/null; then
			sync="(local only)"
		elif [[ "$local_commit" == "$(git rev-parse --short "refs/remotes/origin/$wt_branch" 2>/dev/null)" ]]; then
			sync="(synced)"
		else
			ahead=$(git rev-list --count "refs/remotes/origin/$wt_branch..refs/heads/$wt_branch" 2>/dev/null || echo 0)
			behind=$(git rev-list --count "refs/heads/$wt_branch..refs/remotes/origin/$wt_branch" 2>/dev/null || echo 0)
			parts=()
			(( ahead > 0 )) && parts+=("${ahead} ahead")
			(( behind > 0 )) && parts+=("${behind} behind")
			sync="($(IFS=', '; echo "${parts[*]}"))"
		fi

		printf "  %-30s %-12s %s %s\n" "$wt_branch" "${wt_commit:0:7}" "$sync" "$wt_path"
	done < <(git worktree list)
	echo ""

	# Remote branches not checked out as worktrees
	worktree_branches=$(git worktree list | sed -n 's/.*\[\(.*\)\].*/\1/p')
	has_remote_only=false
	while IFS= read -r ref; do
		branch="${ref#refs/remotes/origin/}"
		[[ "$branch" == "HEAD" ]] && continue
		if ! echo "$worktree_branches" | grep -qx "$branch"; then
			if [[ "$has_remote_only" == false ]]; then
				echo "Remote branches without worktree:"
				has_remote_only=true
			fi
			remote_commit=$(git rev-parse --short "$ref" 2>/dev/null)
			printf "  %-30s %s\n" "$branch" "$remote_commit"
		fi
	done < <(git for-each-ref --format='%(refname)' refs/remotes/origin/)

	if [[ "$has_remote_only" == false ]]; then
		echo "All remote branches have worktrees."
	fi
	;;
lazygit|lg)
	if _is_bare_root; then
		# At project root â€” find the first worktree that isn't the bare repo
		worktree_path=$(git worktree list --porcelain | awk '/^worktree / && !/\.bare$/ {print $2; exit}')
		if [[ -z "$worktree_path" ]]; then
			echo "No worktrees found. Create one first: gwt add <branch>" >&2
			exit 1
		fi
		echo "==> Entering worktree: $worktree_path"
		cd "$worktree_path"
	fi
	exec lazygit "$@"
	;;
*)
	echo "Usage: gwt <command>"
	echo ""
	echo "Commands:"
	echo "  clone <url> [dir]      Clone as bare repo with worktree layout"
	echo "  add <branch> [base]    Add worktree (creates branch if new)"
	echo "  rm <branch>            Remove a worktree"
	echo "  ls                     List all worktrees"
	echo "  status|st              Show sync status of worktrees vs origin"
	echo "  lazygit|lg             Launch lazygit (auto-enters worktree if at bare root)"
	;;
esac
